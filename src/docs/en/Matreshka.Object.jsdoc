/**
@class Matreshka.Object
@classdesc ``Matreshka.Object`` is a class which is responsible for the data  of the key-value pair type. Its task is to separate  the service properties from the data that can be passed to the server or kept in the local storage. The class is inherited from the {@link Matreshka} class and includes all its properties and methods.

Imagine you create a class including ``"a"``, ``"b"`` and ``"c"`` properties. Let's assume that ``"a"`` and ``"b"`` are the properties which must be sent to the server, and ``"c"`` property is just responsible for some application state (for example, it contains the sum of ``"a"`` and ``"b"``). The server does not need the  ``"c"`` property. So we have to separate **the properties which are responsible for the data** from the ones which are not.

In order to declare such properties from the others, you can make use of the {@link Matreshka.Object#addDataKeys} method.
```js
this.addDataKeys( 'a b' );

this.a = 1;
this.b = 2;
this.c = 3;
```

If you don't know which properties are specified in advance, you can always use the {@link Matreshka.Object#jset} method, which declares not only the properties responsible for the data but sets their values at once.
```js
this.jset({
	a: 1,
	b: 2
});

this.c = 3;
```

After the application has found out what is data, the {@link Matreshka.Object} instance can be converted into an ordinary object by the {@link Matreshka.Object#toJSON} method and passed to the server or kept in the local  DB (for example, in ``localStorage``).
```js
// will return the object { a: 1, b: 2 }
this.toJSON();
```

The ``modify`` event is generated on changing the properties which are responsible for the data
```js
this.on( 'modify', function() {
	alert( 'Object is modified' );
});
```
@param {object} [data] - data
@inherits Matreshka
@example <caption>The creation of the instance.</caption>
new MK.Object;
@example <caption>The creation of the instance with two specified properties.</caption>
// the same as new MK.Object().jset({ a: 1, b: 2 });
new MK.Object({ a: 1, b: 2 });
@example <caption>The inheritance</caption>
var MyClass = Class({
	'extends': MK.Object,
	constructor: function() {
		this.sayHello();
	},
	sayHello: function() {
		alert("Hello World!");
	}
});
@example <caption>The inheritance using ECMAScript 2015 syntax</caption>
class MyClass extends MK.Object {
	constructor() {
		this.sayHello();
	}
	sayHello() {
		alert("Hello World!");
	}
}
@example <caption>Data enumerating, using the cycle for..of from ECMAScript 2015</caption>
var mkObject = new MK.Object({ a: 1, b: 2 });
for(let item of mkObject) {
	console.log( item ); // 1 .. 2
}
*/

/**
@member {boolean} Matreshka.Object#isMKObject
@summary The ``isMKObject`` property always equals ``true``.  It is used for checking if the object is an instance of {@link Matreshka.Object}.
@example
alert( object.isMKObject );
*/


/**
@method Matreshka.Object#keys
@summary Returns the array of keys which are responsible for the data 
@returns {array} keys
@example
var keys = this.keys();
*/


/**
@method Matreshka.Object#on
@since 0.2
@summary works the same as {@link Matreshka#on}, but additionally it allows to dynamically hang handlers on the properties which are responsible for the data without direct specifying the property name.
@example
var mkObject = new MK.Object();

mkObject.on( '@something', function() {
	alert( 'something happens' )
});

mkObject.jset( 'x', new MK );

mkObject.x.trigger( 'something' );
*/ 


/**
@method Matreshka.Object#hasOwnProperty
@summary checks if there is a property which is responsible for the data with the given key in the instance. 
@param {string} key
@returns {matreshkaObject} self
@example
var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.hasOwnProperty( 'a' ); // true

mkObject.hasOwnProperty( 'b' ); // true

mkObject.hasOwnProperty( 'c' ); // false
*/


/**
@method Matreshka.Object#toObject
@summary converts the {@link Matreshka.Object}  instance into an ordinary object, but it doesn't convert the properties which are included in it.
@returns {object}
@example <caption>Basic usage</caption>
var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toObject(); // returns { a: 1, b: 2 }
*/


/**
@method Matreshka.Object#toNative
@summary does the same as {@link Matreshka.Object#toObject}
@returns {object}
@example <caption>Usage</caption>
var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.toNative(); // returns { a: 1, b: 2 }
*/


/**
@method Matreshka.Object#toJSON
@summary converts the instance and {@link Matreshka.Object} internal properties  into an ordinary object.
@returns {object}
@example
var mkObject = new MK.Object({
	a: 1,
	b: 2,
	c: new MK.Object({
		d: 3,
		e: 4
	})
});

// returns  { a: 1, b: 2, c: { d: 3, e: 4 } }
mkObject.toJSON();
*/


/**
@method Matreshka.Object#keyOf
@summary searches for the specified property value among others which are responsible for the data and returns the key if this value has been found (the <code>Array.prototype.indexOf</code> prototype)
@prop {*} value - a value of any type which should be found among the data
@returns {string|null}
@example
var mkObject = new MK.Object({
	a: 1,
	b: 2
});

mkObject.keyOf( 1 ); // 'a'

mkObject.keyOf( 2 ); // 'b'

mkObject.keyOf( 3 ); // null
*/


/**
@method Matreshka.Object#jset
@fires change
@fires change:KEY
@fires modify
@summary sets the property and adds the key to the list of keys which are responsible for the data.
@desc This method does two things:

1\. sets the specified value to the given property.

2\. adds the key of the property to the data list and it makes the property available for using in the {@link Matreshka.Object#each}, {@link Matreshka.Object#keys}, {@link Matreshka.Object#toObject} and {@link Matreshka.Object#toJSON} methods ).

Apart from that, the method works the same as {@link Matreshka#set}.

@see {@link Matreshka#set}

@param {string} key - The key
@param {*} value - The value
@param {eventOptions} [evtOpts] - The event object

@returns {matreshkaObject} self

@example
this.jset( 'a', 1 ).jset( 'b', 2 );

@example
this.jset( 'a', 1 ).jset( 'b', 2 );

// assign 3 to the 'c' property,
// but do not add the key to the list of keys which are responsible for the data
this.set( 'c', 3 );

this.each( function( value, key ) {
	console.log( key, value ); 
});

// displays  'a' 1 and 'b' 2

console.log( this.keys() ); // displays  [ 'a', 'b' ]

console.log( this.toJSON() ); // displays  { a: 1, b: 2 }

@example <caption>After using the {@link Matreshka.Object#jset} method, you can work with the property like with an ordinary one</caption>
this.jset( 'a', 1 ).jset( 'b', 2 );
this.set( 'a', 3 ); 
this.b = 4;
*/

/**
@method Matreshka.Object#jset
@variation 2
@summary alternative syntax of the {@link Matreshka.Object#jset} method that uses the key-value object for setting several properties at once.
@param {object} keyValuePairs - the key-value object
@param {eventOptions} evtOpts - the event object

@returns {matreshkaObject} self

@example
this.jset({
	a: 1,
	b: 2
});
@example <caption>The usage of the event object</caption>
this.jset({
	a: 1,
	b: 2
}, { silent: true });
*/


/**
@method Matreshka.Object#remove
@fires delete
@fires delete:KEY
@fires modify
@summary deletes the property from the {@link Matreshka.Object} class instance and from  the list of keys which are responsible for the data.
@see {@link Matreshka#remove}
@param {string} key - The key (or the list of keys which are separated by spaces)
@param {eventOptions} [evtOptions] - The event object
@returns {matreshkaObject} self
@example
this.remove( 'myKey' );
this.remove( 'myKey1 myKey2' );
@example <caption>The usage of the event object</caption>
this.remove( 'myKey', { silent: true } );
*/


/**
@method Matreshka.Object#addDataKeys
@summary Добавляет ключи в список ключей, отвечающих за данные
@desc Этот метод применяется тогда, когда нужно объявить ключи, отвечающие за данные, но значения соответствующих свойств еще не известны.
@param {string|array} keys - Ключ, или ключи разделенные пробелами, или массив ключей
@returns {matreshkaObject} self
@example
this.addDataKeys( 'a b' );
@example
this.addDataKeys( [ 'a', 'b' ] );
@example
this.addDataKeys( 'a', 'b' );
@example <caption>Пример с {@link Matreshka.Object#each}</caption>
this.addDataKeys( 'a b' );

this.each( function( value, key ) {
	console.log( key, value );
});
// выводит 'a' undefined and 'b' undefined
*/


/**
@method Matreshka.Object#removeDataKeys
@summary Удаляет ключи из списка ключей, отвечающих за данные (но не удаляет свойство)
@param {string|array} keys - Ключб или ключи разделенные пробеламиб или массив ключей
@returns {matreshkaObject} self
@example
this.removeDataKeys( 'a b' );
@example
this.removeDataKeys( [ 'a', 'b' ] );
@example
this.removeDataKeys( 'a', 'b' );
*/


/**
@method Matreshka.Object#each
@summary Перебирает свойства, отвечающие за данные
@desc Метод очень похож на ``Array.prototype.forEach``
@param {function} callback - Функция, которая вызывается на каждой итерации
@param {*} [thisArg] - Контекст функции
@returns {matreshkaObject} self
@example
this.each( function( value, key ) {
	... 
}, this );
@example
this
	.jset({ a: 1, b: 2 })
	.addDataKeys( 'c' )
	.each( function( value, key ) {
		console.log( key, value );
	}, this );
; 
// >>> a 1, b 2, c undefined
*/
	
